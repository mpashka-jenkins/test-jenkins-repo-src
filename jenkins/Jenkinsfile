#!groovy


import com.cloudbees.plugins.credentials.CredentialsProvider
import org.jenkinsci.plugins.plaincredentials.StringCredentials
import org.jenkinsci.plugins.workflow.cps.GlobalVariable

node {
    def checkoutResult = checkout scm
    stage('Build') {

        def envVars = env.getEnvironment()
        def workspace = pwd()

/*
        String script_root = "${workspace}/freebsd-ci"
        String build_script = "${script_root}/scripts/build/build1.sh"
        String build_ufs_script = "${script_root}/scripts/build/build-ufs-image.sh"

        dir ("freebsd-ci") {
            git changelog: false, poll: false, url: "${script_url}"
        }
*/

//        return deleteDir()

// Write out the new json config file, to be used by subsequent scripts
//        writeFile file: 'config.json', text: json_str

        echo "checkout result: ${checkoutResult}"
        echo "scm: ${scm}"
        echo "env: ${envVars}"
        echo "workspace: ${workspace}"

/*
        echo("scm. branches: ${scm.branches}, doGenerateSubmoduleConfigurations: ${scm.doGenerateSubmoduleConfigurations} , " +
                "extensions: ${scm.extensions}, userRemoteConfigs: ${scm.userRemoteConfigs}")

        userRemoteConfigs = scm.userRemoteConfigs
        echo("name: ${userRemoteConfigs.name}, refspec: ${userRemoteConfigs.refspec}, url: ${userRemoteConfigs.url}, " +
                "credentialsId: ${userRemoteConfigs.credentialsId}")

        sh 'ls'


        echo 'Hello world from my pipeline'

        echo '------------ env'
        sh 'env'
        echo '------------ set'
        sh 'set'
        echo '------------'
*/

//        String sh(returnStdout: true, script: "git log -n 1 --pretty=format:'%h'").trim()

//        git symbolic-ref HEAD
//        String branch = sh(returnStdout: true, script: "git symbolic-ref --short HEAD").trim()

//        GitSCM

        String targetBranch = env.GITHUB_PR_TARGET_BRANCH
        String sourceBranch = env.GITHUB_PR_SOURCE_BRANCH
//        GITHUB_PR_TITLE


        withCredentials([string(credentialsId: env.MY_GITHUB_TOKEN, variable: 'TOKEN')]) {
            println("Token found: ${TOKEN}")
        }

        dir("dst-project") {
            def userRemoteConfigs = scm.userRemoteConfigs[0]
            dstScm = [
                    $class                           : 'GitSCM',
                    branches                         : [[name: "*/${targetBranch}"], [name: "*/${sourceBranch}"]],
                    doGenerateSubmoduleConfigurations: false,
                    extensions                       : [],
//                    userRemoteConfigs                : scm.userRemoteConfigs
                    userRemoteConfigs                : [[url: 'git@github.com:mpashka/test-jenkins-repo-dst.git', credentialsId: userRemoteConfigs.credentialsId]]
            ]

            checkout(dstScm)
            int targetBranchExists = sh(returnStdout: false, returnStatus: true, script: "git rev-parse --quiet --verify ${targetBranch}").trim()
            if (targetBranchExists != 0) {
                throw new hudson.AbortException("Target branch ${targetBranchExists} doesn't exist in dest project")
            }

            int sourceBranchExists = sh(returnStdout: false, returnStatus: true, script: "git rev-parse --quiet --verify ${sourceBranch}").trim()
            if (sourceBranchExists != 0) {
                sh("git checkout -b ${sourceBranch}")
                sh("git branch --set-upstream-to origin/${sourceBranch}")
            }
            writeFile(name: 'aaa.txt', text: "Creating commit for original ${env.GIT_COMMIT}")
            sh("git add aaa.txt")
            sh("git commit -m \"Commit from original ${env.GIT_COMMIT}\"")
            sh("git push")
            if (sourceBranchExists != 0) {
                sh("git request-pull ")
            }
        }
    }
}
